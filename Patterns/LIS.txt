Approach: 1
------------------------------------------------------------------------
T.C -> O(N^2)
S.C -> O(N)
------------------------------------------------------------------------


public int lengthOfLIS(int[] nums) {
    int n = nums.length;

    int[] lis = new int[n];
    Arrays.fill(lis, 1);

    for(int i = 0; i < n; i++){
        for(int j = 0; j < i; j++){
            if(nums[j] < nums[i]){
                lis[i] = Math.max(lis[i], 1 + lis[j]);
            }
        }
    }

    int res = 0;
    for(int j = 0; j < n; j++){
        res = Math.max(res, lis[j]);
    }
    return res;
}



Approach: 2
------------------------------------------------------------------------
T.C -> O(NlongN)
S.C -> O(N)
------------------------------------------------------------------------

public int lengthOfLIS(int[] nums) {
    int INF = 10001;
    int n = nums.length;

    // dp[i]: Minimum element where a LIS of length i ends. 
    int[] dp = new int[n + 1];
    Arrays.fill(dp, INF);
    dp[0] = -INF;

    for (int i = 0; i < n; i++) {
        int index = justGreaterOrEqual(dp, nums[i]);
        if(index <= n) dp[index] = nums[i];
    }

    int len = 1;
    while (len <= n && dp[len] != INF)
      len++;

    return len - 1;
  }

  public int justGreaterOrEqual(int[] dp, int target) {
    int res = -1;
    int lo = 0, hi = dp.length-1;

    while (lo <= hi) {
      int mid = (lo + hi) >> 1;

      if (dp[mid] < target)
        lo = mid + 1;

      else {
        res = mid;
        hi = mid - 1;
      }
    }
    return res;
  }
